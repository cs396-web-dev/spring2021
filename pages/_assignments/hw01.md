---
layout: assignment-two-column
title: Writing a Web API
abbreviation: HW1
type: homework
due_date: 2021-04-11
ordering: 1
draft: 1
points: 15
---

<a class="nu-button" href="/spring2021/course-files/assignments/cs396_api.zip">cs396_api.zip<i class="fas fa-download" aria-hidden="true"></i></a>

In this assignment, you will create and deploy a web service which can be used to search for information about the hit BBC show _Doctor Who_. When a user asks for this information, your API will process their request and send back the specified data. The user will also be able to add and remove information to and from the service, as well as (optionally) save lists of their favorite characters.

<img class="large frame" src="/spring2021/assets/images/hw1/img1.png"/>

If you haven't already, complete the steps described in [Lab 1](/spring2021/assignments/lab01) to get your Express server up and running.

## Part 1: Setup

Depending on your background, most of the code you've written for previous courses took the form of a _program_, which runs once and then terminates. In this homework, we will be writing a _service_, which runs indefinitely and provides utilities that can be called on by other programs.

You will be using the [Express](https://expressjs.com/) framework to build your service. As in Lab 1, to run the server, type `npm start` into your terminal window:

```bash
$ npm start
Application listening on PORT: 8081
Trying to connect to database...
Could not connect to database.
```

The server is now listening for all requests that are received by port 8081. Don't worry about the output that mentions database connections; we'll get to that in Homework 2.

To test our API, we're going to be using [Postman](https://www.postman.com/downloads/), which is a GUI that lets us send HTTP requests to a specified endpoint. Download Postman, open it up, and put `http://localhost:8081` in the "Enter request URL" bar. Make sure GET is selected in the dropdown and click Send; you should see the response from the request as below:

<img class="large frame" src="/spring2021/assets/images/hw1/img2.png"/>

You can use Postman similarly to debug all the routes we will be writing in this assignment.

## Part 2: Assignment Information

### Express Routes

Open `routes.js` and examine the first route. All HTTP routes consist of 3 components:
- The path, which will be appended to the host route to be accessed by the front-end application
- The HTTP method, in this case GET, which describes the type of information transfer that should take place
- The request handler, which processes incoming information and sends back a JSON response

```javascript
router.route("/")                                 // Path
    .get((_req, res) => {                         // HTTP Method
        console.log("GET /");
        res.status(200).send("App is running");   // Handler
    });
```

This first route simply sends the receiver a response with a message saying "App is running". Instead of a normal function, which uses `return` to output a value, an API uses the `.send()` method to send a value back to the system requesting it (in this case, Postman). Messages between the server and client are sent via JSON, which is a standardized notation for structured data. Routes can send back any kind of data. In this example, it sends back a string with the message "App is running".

There are two ways in which data can be sent within requests to be used by the handler. The first is _parameters_, which take the form of colon-prefixed variables in the route path. For example, in the path `"/doctor/:n"`, `n` is a parameter that can be accessed within the handler using `req.params["n"]`.

The second is the _request body_, which takes the form of a JSON object. You can access this object using `req.body`. __NOTE__: GET requests are forbidden from containing request bodies.

All HTTP responses have an attached _status code_, which represents additional information about the request. A list of all valid HTTP status codes can be found [here](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status). For this assignment, all routes should return a `200` status code for a valid request unless POST is used, in which case a `201` status should be used. If a requests asks for information about data that does not exist (e.g. retrieving a Doctor with an id that isn't present in the data), a `404` code should be used.

### Data

The data needed to create the API can be found in `data.js` and can be accessed via the `data` variable. Your job is to implement all the routes in `routes.js`, using the available data to send, update, and store any relevant information.

A list of objects representing the Doctors is stored at `data.doctors`, where each object contains the following fields:

- `_id`: A unique identifier for the object.
- `name`: The name of the actor/actress who played The Doctor.
- `seasons`: A list of the seasons for which this actor played The Doctor.

A list of objects representing the Doctor's companions is stored at `data.companions`, where each object contains the following fields:

- `_id`: A unique identifier for the object.
- `name`: The name of the actor/actress who played the character.
- `character`: The name of the character.
- `doctors`: A list of the `_id`s of the doctors with whom the companion travelled.
- `seasons`: A list of the seasons during which this character appears
- `alive`: A boolean representing whether the character is alive or dead.

{:#routes}
## Part 3: Writing the API (12 Points)

Your job is to replace `res.status(501).send()` in each route with your own code that sends back a response alongside an appropriate status (described earlier).

Implement the following GET routes.

<table>
    <th>
        Method/Route
        <td>Response <code>data</code> Value</td>
        <td>Response <code>data</code> Type</td>
        <td>Points</td>
    </th>
    <tr>
        <td>GET /doctor</td>
        <td>A list of all Doctor objects</td>
        <td>Array&lt;Object&gt;</td>
        <td>0.5</td>
    </tr>
    <tr>
        <td>GET /doctor/:id</td>
        <td>The Doctor object with the specified id</td>
        <td>Object</td>
        <td>0.5</td>
    </tr>
    <tr>
        <td>GET /doctor/:id/companions</td>
        <td>A list of the companions that travelled with the doctor with the specified id</td>
        <td>Array&lt;Object&gt;</td>
        <td>1</td>
    </tr>
    <tr>
        <td>GET /doctor/:id/companions/longest</td>
        <td>The companion who travelled with this Doctor for the greatest number of seasons; If there's a tie, send the first listed</td>
        <td>Object</td>
        <td>1</td>
    </tr>
    <tr>
        <td>GET /doctor/:id/goodparent</td>
        <td><i>true</i> if every companion who travelled with this doctor is alive; Otherwise, <i>false</i></td>
        <td>boolean</td>
        <td>1</td>
    </tr>
    <tr>
        <td>GET /companion</td>
        <td>A list of all companion objects</td>
        <td>Array&lt;Object&gt;</td>
        <td>0.5</td>
    </tr>
    <tr>
        <td>GET /companion/:id</td>
        <td>The companion object with the specified id</td>
        <td>Object</td>
        <td>0.5</td>
    </tr>
    <tr>
        <td>GET /companion/:id/doctors</td>
        <td>A list of the Doctors with whom this companion travelled</td>
        <td>Array&lt;Object&gt;</td>
        <td>1</td>
    </tr>
    <tr>
        <td>GET /companion/:id/friends</td>
        <td>A list of the companions who appeared on at least one of the same seasons as this companion</td>
        <td>Array&lt;Object&gt;</td>
        <td>1</td>
    </tr>
    <tr>
        <td>GET /companion/crossover</td>
        <td>A list of the companions who travelled with multiple doctors</td>
        <td>Array&lt;Object&gt;</td>
        <td>1</td>
    </tr>
</table>

The next set of routes involves storing and manipulating data. For now, you will accomplish this by adding and removing items from the `data` object. Since the server runs continually in the background, any changes you make to the `data` object will persist between requests, letting us simulate a database. However, the changes you make will not persist between server runs; if you restart the server, the data object will revert to its initial state.

Notice that the PATCH and DELETE methods detailed below can fail to find an object if it does not exist within `data`. In these cases, you should mark the status of the response as `404`, indicating that the requested resource could not be found.

__Note__: Fields marked with a question mark are optional and may not be included in some request bodies.

__Note 2 (Electric Boogaloo)__: Receiving two POST requests with identical bodies should create two different objects with distinct ids. It's your job to figure out how to make sure that no two objects have the same `_id`. One way to do this might be to append `Date.now()` to a string identifier, since `Date.now()` will return a different value each time it is called (you could also generate a random number and use that instead).

<table>
    <th>
        Method/Route
        <td>Effect</td>
        <td>Request Body</td>
        <td>Response <code>data</code> Value</td>
        <td>Response <code>data</code> Type</td>
        <td>Points</td>
    </th>
    <tr>
        <td>POST /doctor</td>
        <td>Create a new Doctor object and store it. You must create a new unique identifier for the object, which you should send back to the client.</td>
        <td>{ name: string, seasons: Array&lt;number&gt; }</td>
        <td>The id of the created Doctor object</td>
        <td>string</td>
        <td>0.5</td>
    </tr>
    <tr>
        <td>POST /companion</td>
        <td>Create a new companion object and store it. You must create a new unique identifier for the object, which you should send back to the client.</td>
        <td>{ name: string, character: string, doctors: Array&lt;number&gt;, seasons: Array&lt;number&gt;, alive: boolean }</td>
        <td>The id of the created companion object</td>
        <td>string</td>
        <td>0.5</td>
    </tr>
    <tr>
        <td>PATCH /doctor/:id</td>
        <td>Update the fields of the Doctor object with the specified id to match the fields in the request body. If a field is not present in the request body, leave it untouched in the Doctor object.</td>
        <td>{ name?: string, seasons?: Array&lt;number&gt; }</td>
        <td>The parameter id</td>
        <td>string</td>
        <td>1</td>
    </tr>
    <tr>
        <td>PATCH /companion/:id</td>
        <td>Update the fields of the companion object with the specified id to match the fields in the request body. If a field is not present in the request body, leave it untouched in the companion object.</td>
        <td>{ name?: string, character?: string, doctors?: Array&lt;number&gt;, seasons?: Array&lt;number&gt;, alive?: boolean }</td>
        <td>The parameter id</td>
        <td>string</td>
        <td>1</td>
    </tr>
    <tr>
        <td>DELETE /doctor/:id</td>
        <td>Delete the entry for the Doctor with the specified id.</td>
        <td>{}</td>
        <td>The parameter id</td>
        <td>string</td>
        <td>0.5</td>
    </tr>
    <tr>
        <td>DELETE /companion/:id</td>
        <td>Delete the entry for the companion with the specified id.</td>
        <td>{}</td>
        <td>The parameter id</td>
        <td>string</td>
        <td>0.5</td>
    </tr>
</table>

## Part 4: Deploying the API (3 points)

For the first few assignments in this class, we will be using Heroku, a lightweight hosting service, to deploy our applications to the cloud. Heroku is generally meant for smaller prototype applications, and as such is not acceptable for building large-scale applications (see AWS and friends for that). However, it's perfect for our use case.

### Create a Heroku App

[Sign up](https://signup.heroku.com/identity) for a Heroku account and indicate your primary development language as Node.js.

Click 'Create a new app' and give the app a name on the Heroku website. You will be brought to a dashboard where you can manage your application.

### Connect Heroku to GitHub

In the "Deploy" tab of your Heroku dashboard, switch your app's deployment method from the Heroku CLI to GitHub. Then, click the "Connect to Github" button and search for the repository you created earlier. Press the "connect" button to have Heroku track changes on the main branch of your repository.

<img class="large frame" src="/spring2021/assets/images/hw1/img3.png"/>

Now, all you have to do to deploy your app is to hit the "Deploy Branch" button with "main" selected. Now, if you open your Heroku app, you should see a message indicating that your app is running! You should also be able to access your routes through Postman using the link to your app rather than localhost.

## Extra Credit (Up to 3 points)

The last few routes involve setting up a favorites system in which a user can save their favorite Doctors and companions to find again later. Feel free to use whatever data structure(s) you feel appropriate to create your favorites "database". Return 404 HTTP status codes for the POST and DELETE requests if the entry with the specified `_id` does not exist.

<table>
    <th>
        Method/Route
        <td>Effect</td>
        <td>Request Body</td>
        <td>Response <code>data</code> Value</td>
        <td>Response <code>data</code> Type</td>
        <td>Points</td>
    </th>
    <tr>
        <td>GET /doctor/favorite</td>
        <td>Return a list  of saved Doctor objects.</td>
        <td>N/A</td>
        <td>A list of saved Doctor objects.</td>
        <td>Array&lt;Object&gt;</td>
        <td>0.5</td>
    </tr>
    <tr>
        <td>GET /companion/favorite</td>
        <td>Return a list of saved companion objects.</td>
        <td>N/A</td>
        <td>A list of saved companion objects.</td>
        <td>Array&lt;Object&gt;</td>
        <td>0.5</td>
    </tr>
    <tr>
        <td>POST /doctor/:id/favorite</td>
        <td>Add the Doctor with the specified id to the user's favorites.</td>
        <td>{}</td>
        <td>The parameter id</td>
        <td>string</td>
        <td>0.5</td>
    </tr>
    <tr>
        <td>POST /companion/:id/favorite</td>
        <td>Add the companion with the specified id to the user's favorites.</td>
        <td>{}</td>
        <td>The parameter id</td>
        <td>string</td>
        <td>0.5</td>
    </tr>
    <tr>
        <td>DELETE /doctor/:id/favorite</td>
        <td>Delete the Doctor with the specified id from the user's favorites.</td>
        <td>{}</td>
        <td>The parameter id</td>
        <td>string</td>
        <td>0.5</td>
    </tr>
    <tr>
        <td>DELETE /companion/:id/favorite</td>
        <td>Delete the companion with the specified id from the user's favorites.</td>
        <td>{}</td>
        <td>The parameter id</td>
        <td>string</td>
        <td>0.5</td>
    </tr>
</table>

## What to Turn In

Below is a video showing the expected output of some requests to the server (we recommend you pause at each step to compare your server's output to the video). The video does _not_ show every possible input we will be testing during grading, but it should give you a good idea whether or not you're on the right track.

When you're done, you should submit the following to Canvas:

- Your completed `routes.js` file
- A link to your running Heroku app

Make sure to upload the file by Tuesday night at midnight. Please be careful that you __don't just upload the original starter file__, but that you submit __YOUR CODE__.
